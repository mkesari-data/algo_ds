package com.bstpractise;

import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.LinkedBlockingQueue;

public class BSTUtil {

	class Node {
		double value;
		Node left;
		Node right;

		Node(double value) {
			this.value = value;
		}
	}

	Node root;
	Node parent;

	

	public Node find(double value) {
		Node temp = root;
		parent = root;
		while (temp != null) {
			if (value == temp.value) {
				return temp;
			} else if (value > temp.value) {
				parent = temp;
				temp = temp.right;
			} else {
				parent = temp;
				temp = temp.left;
			}
		}
		return null;
	}

	/**
	 * This
	 * 
	 * @param size : Provide BST Size. Those many elements will be generated by
	 *             RandomAPI.
	 */
	public void insert(int size) {

		Random r = new Random();
		for (int i = 0; i < size; i++) {
			double nodevalue = Math.ceil(r.nextDouble() * 100);
			System.out.println(nodevalue + "*Inserting*");
			insertValue(nodevalue);
		}

	}

	private void insertValue(double nodevalue) {
		if (root == null) {
			root = new Node(nodevalue);
			return;
		}
		Node ref = find(nodevalue);
		if (ref != null) {
			System.out.println("Value Already Available");
		} else {
			if (nodevalue > parent.value) {
				parent.right = new Node(nodevalue);
			} else {
				parent.left = new Node(nodevalue);
			}
		}
	}

	public void prettyDisplayBST() {
		displayWithSpaces(root, 5, "r");
	}

	private void displayWithSpaces(Node n, int no_ofspaces, String side) {
		if (n == null)
			return;
		System.out.printf("%" + no_ofspaces + "s\n", String.valueOf(n.value).concat("(").concat(side).concat(")"));
		displayWithSpaces(n.left, no_ofspaces + 5, "L");
		displayWithSpaces(n.right, no_ofspaces + 5, "R");

	}

	private void auxDisplay(Node root, int spaces, String lable) {
		if (root == null)
			return;
		auxDisplay(root.right, spaces + 5, "r");
		System.out.printf("%" + spaces + "s\n", String.valueOf(root.value).concat("(").concat(lable).concat(")"));
		auxDisplay(root.left, spaces + 5, "l");
	}

	public void BSTNormalDisplay() {
		auxDisplay(root, 10, "S");
	}

	public void levelOrder() {
		Queue<Node> q = new LinkedBlockingQueue<Node>();
		q.add(root);
		Node n = new Node(-1);
		q.add(n);

		while (!q.isEmpty()) {
			Node t = q.poll();
			if (t.value != -1) {
				System.out.print(t.value + "-->");
				Node left = t.left;
				Node right = t.right;
				if (left != null)
					q.add(left);
				if (right != null)
					q.add(right);
			} else {
				if (!q.isEmpty())
					q.add(n);
			}
		}

	}
	
	
	public String leverOrderSerialization() {
		java.util.Queue<Node> q = new java.util.LinkedList<>();
		q.add(root);
		StringBuilder binaryTreeinString=new StringBuilder();
		while (!q.isEmpty()) {
			Node qEntry = q.poll();
			if(qEntry==null) {
				binaryTreeinString.append("#,");
				continue;
			}
			binaryTreeinString.append(qEntry.value+",");
			Node leftNode = qEntry.left;
			Node rightNode = qEntry.right;
			
			q.add(leftNode);
			q.add(rightNode);

		}
		return binaryTreeinString.toString();
	}
	
	public void leverOrderDeSerialization(String serializedString) {
		String[] nodeValues = serializedString.split(",");
		Node root = new Node(Double.parseDouble(nodeValues[0]));
		Queue<Node> q = new LinkedList<Node>();
		q.add(root);
		for (int i = 1; i < nodeValues.length - 1;) {

			Node parent = q.poll();

			String leftValue = nodeValues[i++];
			if (!leftValue.equals("#")) {
				Node leftNode = new Node(Double.parseDouble(leftValue));
				parent.left = leftNode;
				q.add(leftNode);
			}

			String rightValue = nodeValues[i++];
			if (!rightValue.equals("#")) {
				Node rightNode = new Node(Double.parseDouble(rightValue));
				parent.right = rightNode;
				q.add(rightNode);
			}

		}
		this.root=root;
	}
	

}
